desc:SideFX Modulator
author:Nomad Monad
version:2.3
options:no_meter

// Rate
slider1:0<0,1,1{Free,Sync}>-Tempo Mode
slider2:1<0.01,10,0.01>-Rate (Hz)
slider3:5<0,17,1{8 bars,4 bars,2 bars,1 bar,1/2,1/4,1/4T,1/4.,1/8,1/8T,1/8.,1/16,1/16T,1/16.,1/32,1/32T,1/32.,1/64}>-Sync Rate
slider4:0<0,1,0.001>-Output
slider5:0<0,1,0.001>-Phase
slider6:1<0,1,0.01>-Depth

// Trigger
slider20:0<0,3,1{Free,Transport,MIDI,Audio}>-Trigger Mode
slider21:0<0,1,1{This Track,MIDI Bus}>-MIDI Source
slider22:0<0,127,1>-MIDI Note (0=any)
slider23:0.5<0,1,0.01>-Audio Threshold
slider24:100<1,2000,1>-Attack (ms)
slider25:500<1,5000,1>-Release (ms)

// LFO Mode
slider28:0<0,1,1{Loop,One Shot}>-LFO Mode
slider29:0<-1,1,0.01>-Curve Shape

// Editor
slider26:2<0,4,1{Off,4,8,16,32}>-Grid
slider27:1<0,1,1{Off,On}>-Snap

// Number of points (2-16)
slider30:4<2,16,1>-Num Points

// Curve points stored in sliders (X1,Y1,X2,Y2,...) - these persist!
slider40:0<0,1,0.001>-P1X
slider41:0<0,1,0.001>-P1Y
slider42:0.33<0,1,0.001>-P2X
slider43:0.33<0,1,0.001>-P2Y
slider44:0.66<0,1,0.001>-P3X
slider45:0.66<0,1,0.001>-P3Y
slider46:1<0,1,0.001>-P4X
slider47:1<0,1,0.001>-P4Y
slider48:0.5<0,1,0.001>-P5X
slider49:0.5<0,1,0.001>-P5Y
slider50:0.5<0,1,0.001>-P6X
slider51:0.5<0,1,0.001>-P6Y
slider52:0.5<0,1,0.001>-P7X
slider53:0.5<0,1,0.001>-P7Y
slider54:0.5<0,1,0.001>-P8X
slider55:0.5<0,1,0.001>-P8Y
slider56:0.5<0,1,0.001>-P9X
slider57:0.5<0,1,0.001>-P9Y
slider58:0.5<0,1,0.001>-P10X
slider59:0.5<0,1,0.001>-P10Y
slider60:0.5<0,1,0.001>-P11X
slider61:0.5<0,1,0.001>-P11Y
slider62:0.5<0,1,0.001>-P12X
slider63:0.5<0,1,0.001>-P12Y
slider64:0.5<0,1,0.001>-P13X
slider65:0.5<0,1,0.001>-P13Y
slider66:0.5<0,1,0.001>-P14X
slider67:0.5<0,1,0.001>-P14Y
slider68:0.5<0,1,0.001>-P15X
slider69:0.5<0,1,0.001>-P15Y
slider70:0.5<0,1,0.001>-P16X
slider71:0.5<0,1,0.001>-P16Y

// Per-segment curve values (15 segments max between 16 points)
// -1 = ease-out (bend inward), 0 = straight, +1 = ease-in (bend outward)
slider72:0<-1,1,0.01>-Seg1 Curve
slider73:0<-1,1,0.01>-Seg2 Curve
slider74:0<-1,1,0.01>-Seg3 Curve
slider75:0<-1,1,0.01>-Seg4 Curve
slider76:0<-1,1,0.01>-Seg5 Curve
slider77:0<-1,1,0.01>-Seg6 Curve
slider78:0<-1,1,0.01>-Seg7 Curve
slider79:0<-1,1,0.01>-Seg8 Curve
slider80:0<-1,1,0.01>-Seg9 Curve
slider81:0<-1,1,0.01>-Seg10 Curve
slider82:0<-1,1,0.01>-Seg11 Curve
slider83:0<-1,1,0.01>-Seg12 Curve
slider84:0<-1,1,0.01>-Seg13 Curve
slider85:0<-1,1,0.01>-Seg14 Curve
slider86:0<-1,1,0.01>-Seg15 Curve

// Current playhead position (for UI display, read-only from UI perspective)
slider87:0<0,1,0.001>-Playhead Position

// Offset and Bipolar mode
slider88:0<0,1,0.01>-Offset
slider89:0<0,1,1{Unipolar,Bipolar}>-Bipolar Mode

// Audio source selection (for Audio trigger mode)
// 0 = Internal (main input spl0/spl1), 1 = External (sidechain spl2/spl3)
slider90:0<0,1,1{Internal,External}>-Audio Source

// Debug: shows input level being received (read-only)
slider91:0<0,1,0.001>-Input Level (Debug)

@init
MAX_NODES = 16;

// Memory for spline coefficients only (points are in sliders)
mem_c1 = 1000;
mem_c2 = 1020;
mem_c3 = 1040;
mem_tempx = 1060;
mem_tempy = 1080;

// Temp arrays for sorted points
mem_sorted_x = 1100;
mem_sorted_y = 1120;

// State
lfo_phase = 0;
env_value = 1;
triggered = 0;
current_tempo = 120;
rate = 1;
last_play_state = 0;

// Drag state
drag_node = -1;
hover_node = -1;
cap_mode = 0;
last_mouse_cap = 0;
drag_start_x = 0;
drag_start_y = 0;

// Delete state
node_x = 0;
min_x_idx = 0;
max_x_idx = 0;
min_x_val = 0;
max_x_val = 0;

// Get X value from slider
function get_x(i) (
  i == 0 ? slider40 : i == 1 ? slider42 : i == 2 ? slider44 : i == 3 ? slider46 :
  i == 4 ? slider48 : i == 5 ? slider50 : i == 6 ? slider52 : i == 7 ? slider54 :
  i == 8 ? slider56 : i == 9 ? slider58 : i == 10 ? slider60 : i == 11 ? slider62 :
  i == 12 ? slider64 : i == 13 ? slider66 : i == 14 ? slider68 : slider70;
);

// Get Y value from slider
function get_y(i) (
  i == 0 ? slider41 : i == 1 ? slider43 : i == 2 ? slider45 : i == 3 ? slider47 :
  i == 4 ? slider49 : i == 5 ? slider51 : i == 6 ? slider53 : i == 7 ? slider55 :
  i == 8 ? slider57 : i == 9 ? slider59 : i == 10 ? slider61 : i == 11 ? slider63 :
  i == 12 ? slider65 : i == 13 ? slider67 : i == 14 ? slider69 : slider71;
);

// Set X value to slider
function set_x(i, v) (
  i == 0 ? (slider40 = v; slider_automate(slider40);) :
  i == 1 ? (slider42 = v; slider_automate(slider42);) :
  i == 2 ? (slider44 = v; slider_automate(slider44);) :
  i == 3 ? (slider46 = v; slider_automate(slider46);) :
  i == 4 ? (slider48 = v; slider_automate(slider48);) :
  i == 5 ? (slider50 = v; slider_automate(slider50);) :
  i == 6 ? (slider52 = v; slider_automate(slider52);) :
  i == 7 ? (slider54 = v; slider_automate(slider54);) :
  i == 8 ? (slider56 = v; slider_automate(slider56);) :
  i == 9 ? (slider58 = v; slider_automate(slider58);) :
  i == 10 ? (slider60 = v; slider_automate(slider60);) :
  i == 11 ? (slider62 = v; slider_automate(slider62);) :
  i == 12 ? (slider64 = v; slider_automate(slider64);) :
  i == 13 ? (slider66 = v; slider_automate(slider66);) :
  i == 14 ? (slider68 = v; slider_automate(slider68);) :
  (slider70 = v; slider_automate(slider70););
);

// Set Y value to slider
function set_y(i, v) (
  i == 0 ? (slider41 = v; slider_automate(slider41);) :
  i == 1 ? (slider43 = v; slider_automate(slider43);) :
  i == 2 ? (slider45 = v; slider_automate(slider45);) :
  i == 3 ? (slider47 = v; slider_automate(slider47);) :
  i == 4 ? (slider49 = v; slider_automate(slider49);) :
  i == 5 ? (slider51 = v; slider_automate(slider51);) :
  i == 6 ? (slider53 = v; slider_automate(slider53);) :
  i == 7 ? (slider55 = v; slider_automate(slider55);) :
  i == 8 ? (slider57 = v; slider_automate(slider57);) :
  i == 9 ? (slider59 = v; slider_automate(slider59);) :
  i == 10 ? (slider61 = v; slider_automate(slider61);) :
  i == 11 ? (slider63 = v; slider_automate(slider63);) :
  i == 12 ? (slider65 = v; slider_automate(slider65);) :
  i == 13 ? (slider67 = v; slider_automate(slider67);) :
  i == 14 ? (slider69 = v; slider_automate(slider69);) :
  (slider71 = v; slider_automate(slider71););
);

// Get segment curve value (0-14 for segments between points)
function get_seg_curve(i) (
  i == 0 ? slider72 : i == 1 ? slider73 : i == 2 ? slider74 : i == 3 ? slider75 :
  i == 4 ? slider76 : i == 5 ? slider77 : i == 6 ? slider78 : i == 7 ? slider79 :
  i == 8 ? slider80 : i == 9 ? slider81 : i == 10 ? slider82 : i == 11 ? slider83 :
  i == 12 ? slider84 : i == 13 ? slider85 : slider86;
);

// Set segment curve value
function set_seg_curve(i, v) (
  i == 0 ? (slider72 = v; slider_automate(slider72);) :
  i == 1 ? (slider73 = v; slider_automate(slider73);) :
  i == 2 ? (slider74 = v; slider_automate(slider74);) :
  i == 3 ? (slider75 = v; slider_automate(slider75);) :
  i == 4 ? (slider76 = v; slider_automate(slider76);) :
  i == 5 ? (slider77 = v; slider_automate(slider77);) :
  i == 6 ? (slider78 = v; slider_automate(slider78);) :
  i == 7 ? (slider79 = v; slider_automate(slider79);) :
  i == 8 ? (slider80 = v; slider_automate(slider80);) :
  i == 9 ? (slider81 = v; slider_automate(slider81);) :
  i == 10 ? (slider82 = v; slider_automate(slider82);) :
  i == 11 ? (slider83 = v; slider_automate(slider83);) :
  i == 12 ? (slider84 = v; slider_automate(slider84);) :
  i == 13 ? (slider85 = v; slider_automate(slider85);) :
  (slider86 = v; slider_automate(slider86););
);

// Sort points and copy to temp arrays
function sort_and_copy() local(i, j, min_idx, min_x, temp_x, temp_y, n) (
  n = slider30;

  // Copy to temp
  i = 0;
  loop(n,
    mem_sorted_x[i] = get_x(i);
    mem_sorted_y[i] = get_y(i);
    i += 1;
  );

  // Selection sort by X
  i = 0;
  loop(n - 1,
    min_idx = i;
    min_x = mem_sorted_x[i];
    j = i + 1;
    loop(n - i - 1,
      mem_sorted_x[j] < min_x ? (
        min_idx = j;
        min_x = mem_sorted_x[j];
      );
      j += 1;
    );
    min_idx != i ? (
      temp_x = mem_sorted_x[i];
      temp_y = mem_sorted_y[i];
      mem_sorted_x[i] = mem_sorted_x[min_idx];
      mem_sorted_y[i] = mem_sorted_y[min_idx];
      mem_sorted_x[min_idx] = temp_x;
      mem_sorted_y[min_idx] = temp_y;
    );
    i += 1;
  );
);

// Calculate spline coefficients
function update_spline() local(i, dx, m, m_next, cm, dx_next, n) (
  n = slider30;
  sort_and_copy();

  // Calculate slopes
  i = 0;
  loop(n - 1,
    dx = mem_sorted_x[i + 1] - mem_sorted_x[i];
    dx < 0.0001 ? dx = 0.0001;
    mem_tempy[i] = (mem_sorted_y[i + 1] - mem_sorted_y[i]) / dx;
    mem_tempx[i] = dx;
    i += 1;
  );

  // First derivatives (c1)
  mem_c1[0] = mem_tempy[0];
  i = 1;
  loop(n - 2,
    m = mem_tempy[i - 1];
    m_next = mem_tempy[i];
    m * m_next <= 0 ? (
      mem_c1[i] = 0;
    ) : (
      dx = mem_tempx[i - 1];
      dx_next = mem_tempx[i];
      cm = dx + dx_next;
      mem_c1[i] = 3.0 * cm / ((cm + dx_next) / m + (cm + dx) / m_next);
    );
    i += 1;
  );
  mem_c1[n - 1] = mem_tempy[n - 2];

  // c2 and c3
  i = 0;
  loop(n - 1,
    dx = mem_tempx[i];
    dx < 0.0001 ? dx = 0.0001;
    m = mem_tempy[i];
    cm = mem_c1[i] + mem_c1[i + 1] - m - m;
    mem_c2[i] = (m - mem_c1[i] - cm) / dx;
    mem_c3[i] = cm / (dx * dx);
    i += 1;
  );
);

// Apply curve shape to normalized t (0-1)
// curve_shape: -1 = bend inward (ease-out/log), 0 = straight/linear, +1 = bend outward (ease-in/exp)
function apply_curve(t, curve_shape) local(power) (
  curve_shape == 0 ? t : (
    // Convert curve_shape to power: -1 gives 0.5 (sqrt), +1 gives 2 (square)
    power = pow(2, curve_shape);
    pow(t, power);
  );
);

// Evaluate curve with per-segment shape control
// Each segment can have its own curve shape (-1 to +1)
// slider29 acts as global offset added to per-segment values
function eval_spline(x) local(i, n, seg_start, seg_end, seg_len, t_norm, t_curved, y_start, y_end, seg_curve, global_curve, final_curve) (
  n = slider30;
  global_curve = slider29;  // Global curve offset
  x = max(0, min(1, x));

  // Find which segment we're in (sorted by X)
  i = 0;
  while (i < n - 1 && mem_sorted_x[i + 1] < x) ( i += 1; );
  i = max(0, min(i, n - 2));

  // Get segment boundaries
  seg_start = mem_sorted_x[i];
  seg_end = mem_sorted_x[i + 1];
  seg_len = seg_end - seg_start;
  seg_len < 0.0001 ? seg_len = 0.0001;

  // Y values at segment endpoints
  y_start = mem_sorted_y[i];
  y_end = mem_sorted_y[i + 1];

  // Normalized position within segment (0-1)
  t_norm = (x - seg_start) / seg_len;
  t_norm = max(0, min(1, t_norm));

  // Get per-segment curve value and combine with global offset
  seg_curve = get_seg_curve(i);
  final_curve = max(-1, min(1, seg_curve + global_curve));

  // Apply curve shape (0 = linear, negative = ease-out, positive = ease-in)
  t_curved = apply_curve(t_norm, final_curve);

  // Linear interpolation with curved t
  out = y_start + (y_end - y_start) * t_curved;

  max(0, min(1, out));
);

// Find nearest node
function find_nearest(mx, my, threshold) local(i, best, min_dist, dx, dy, dist, n) (
  n = slider30;
  best = -1;
  min_dist = threshold * threshold;
  i = 0;
  loop(n,
    dx = mx - get_x(i);
    dy = my - get_y(i);
    dist = dx * dx + dy * dy;
    dist < min_dist ? ( min_dist = dist; best = i; );
    i += 1;
  );
  best;
);

// Add node
function add_node(x, y) local(n) (
  n = slider30;
  n < MAX_NODES ? (
    set_x(n, x);
    set_y(n, y);
    slider30 = n + 1;
    slider_automate(slider30);
    update_spline();
  );
);

// Remove node
function remove_node(idx) local(i, n) (
  n = slider30;
  // Validation should be done by caller, just perform the removal
  idx >= 0 && idx < n && n > 2 ? (
    i = idx;
    loop(n - idx - 1,
      set_x(i, get_x(i + 1));
      set_y(i, get_y(i + 1));
      i += 1;
    );
    slider30 = n - 1;
    slider_automate(slider30);
    update_spline();
  );
);

function calc_coeff(time_ms) (
  time_ms > 0 ? exp(-1.0 / (srate * time_ms / 1000)) : 0;
);

// Initial spline calc
update_spline();

@slider
attack_coeff = calc_coeff(slider24);
release_coeff = calc_coeff(slider25);
update_spline();

@block
trigger_mode = slider20;
midi_note = slider22;

trigger_mode == 1 ? (
  play_state & 1 ? (
    triggered = 1;
    last_play_state == 0 ? lfo_phase = 0;
  ) : ( triggered = 0; );
  last_play_state = play_state & 1;
);

while (midirecv(offset, msg1, msg2, msg3)) (
  trigger_mode == 2 ? (
    status = msg1 & 0xF0;
    note = msg2;
    velocity = msg3;
    // Note on
    status == 0x90 && velocity > 0 ? (
      (midi_note == 0 || note == midi_note) ? (
        triggered = 1;
        lfo_phase = 0;
      );
    );
    // Note off (0x80 or 0x90 with velocity 0)
    (status == 0x80 || (status == 0x90 && velocity == 0)) ? (
      (midi_note == 0 || note == midi_note) ? (
        triggered = 0;
      );
    );
  );
  midisend(offset, msg1, msg2, msg3);
);

@sample
trigger_mode = slider20;

trigger_mode == 0 ? ( env_value = 1; );
trigger_mode == 1 ? ( triggered ? env_value = 1 : env_value = env_value * release_coeff; );
trigger_mode == 2 ? ( triggered ? env_value = 1 : env_value = env_value * release_coeff; );
trigger_mode == 3 ? (
  // Audio source: 0 = Internal (spl0/spl1 from utility output), 1 = External sidechain (spl2/spl3)
  slider90 < 0.5 ? (
    input_level = max(abs(spl0), abs(spl1));
  ) : (
    input_level = max(abs(spl2), abs(spl3));
  );
  // Debug: expose input level (smoothed for display)
  slider91 = slider91 * 0.95 + input_level * 0.05;
  input_level > slider23 ? (
    triggered = 1;
    env_value = env_value * attack_coeff + (1 - attack_coeff);
  ) : (
    triggered = 0;
    env_value = env_value * release_coeff;
  );
);

// Rate
slider1 == 1 ? (
  current_tempo = tempo;
  current_tempo <= 0 ? current_tempo = 120;
  // 0=8bars,1=4bars,2=2bars,3=1bar,4=1/2,5=1/4,6=1/4T,7=1/4.,8=1/8,9=1/8T,10=1/8.,11=1/16,12=1/16T,13=1/16.,14=1/32,15=1/32T,16=1/32.,17=1/64
  sr = slider3;
  sr == 0 ? beats = 32 : sr == 1 ? beats = 16 : sr == 2 ? beats = 8 : sr == 3 ? beats = 4 :
  sr == 4 ? beats = 2 : sr == 5 ? beats = 1 : sr == 6 ? beats = 1*2/3 : sr == 7 ? beats = 1.5 :
  sr == 8 ? beats = 0.5 : sr == 9 ? beats = 0.5*2/3 : sr == 10 ? beats = 0.75 :
  sr == 11 ? beats = 0.25 : sr == 12 ? beats = 0.25*2/3 : sr == 13 ? beats = 0.375 :
  sr == 14 ? beats = 0.125 : sr == 15 ? beats = 0.125*2/3 : sr == 16 ? beats = 0.1875 : beats = 0.0625;
  rate = current_tempo / 60 / beats;
) : ( rate = slider2; );

// Only advance LFO in Free mode OR when triggered in other modes
one_shot = slider28;
// In one-shot mode, stop advancing once phase reaches 1
(trigger_mode == 0 || triggered) && !(one_shot && lfo_phase >= 1) ? (
  lfo_phase += rate / srate;
  one_shot ? (
    // One shot: clamp at 1, don't wrap
    lfo_phase >= 1 ? lfo_phase = 1;
  ) : (
    // Loop: wrap around
    lfo_phase >= 1 ? lfo_phase -= 1;
  );
);

phase = lfo_phase + slider5;
phase >= 1 ? phase -= 1;

raw_lfo = eval_spline(phase);

// Output raw LFO value (0-1) - offset/depth/bipolar handled by plink settings
// The env_value still applies for attack/release envelope
slider4 = raw_lfo * env_value;
slider87 = phase;  // Expose current playhead position for UI (read-only, no automate)
slider_automate(slider4);
